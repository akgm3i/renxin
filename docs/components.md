# コンポーネント関連
## 1. はじめに

本ドキュメントは、ダーツ練習支援アプリケーションを構成する主要なソフトウェアコンポーネントの役割と、それらの相互作用を定義するものである。「UI/UX仕様詳細」および「データ・API仕様詳細」を技術的な視点から補完する。

## 2. 全体アーキテクチャ概要

本システムは、初期フェーズではクライアントPC内で完結する「ローカルファースト」アーキテクチャを採用する。これにより、オフライン環境での利用やシンプルなデプロイを実現する。将来的な機能拡張や他プラットフォームへの展開を見据え、クライアントとサーバーの役割を論理的に分離した設計とする。

### 2.1. 初期フェーズ (ローカルファースト)

- クライアントアプリケーション (Tauri):
    - 役割: システムの中核。UI表示、ゲームロジック、カメラ制御、データ永続化、リアルタイム通信サーバー機能など、全ての役割を担う。スタンドアロンアプリケーションとして動作する。
    - 構成: UIプロセス (Frontend) と Coreプロセス (Backend/Rust) から成り、両者はIPCで通信する。
    - データ: 全てのデータは、アプリケーションに直接組み込まれた埋め込みデータベース（例: rusqliteライブラリを使用したSQLite）に永続化する。
- 閲覧用ブラウザ:
    - 役割: 同一ローカルネットワーク上の他PCから、リアルタイムでゲーム状況を確認するためのWebブラウザ。
    - 通信: クライアントアプリケーションのCoreプロセスがLAN上に公開するRPCエンドポイントに直接接続する。

### 2.2. 将来的なサーバー分離フェーズ

将来的に、データの一元管理、高度な分析、複数デバイスからのアクセス、ユーザー認証などの要件が発生した場合、サーバーを分離する構成への移行を検討する。このフェーズでは、クライアントアプリケーションはローカルキャッシュを持ち、オフライン時も基本的な機能を提供できる「オフラインファースト」の設計を検討する。

## 3. クライアントアプリケーションの内部構成

クライアントアプリは、Tauriのアーキテクチャに基づき、2つの主要プロセスで構成される。

- UIプロセス (Frontend):
    - 役割: HTML, CSS, TypeScriptで構築されたユーザーインターフェースの描画と、ユーザーからのタッチイベントの受付を担当する。
    - 責務: 画面の表示とアニメーション、ユーザー入力の検知。ビジネスロジックは持たない。
- Coreプロセス (Backend - Rust):
    - 役割: アプリケーションの頭脳。UIプロセスからの要求を受け、全てのビジネスロジックを実行する。
    - 責務:
        - ゲームロジックの実行（スコア計算、ラウンド進行管理など）
        - カメラデバイスの制御と動画録画
        - 埋め込みデータベースライブラリ（rusqliteなど）を介した、単一ファイルへの全てのデータの読み書き
        - ローカルネットワーク上でのRPCサーバー機能の提供と、接続クライアントへのリアルタイム通知
- プロセス間通信 (IPC):
    - UIプロセスとCoreプロセスは、Tauriが提供するIPCブリッジを介して通信する。UIはCoreが公開するRust関数を、あたかもTypeScriptの関数のように呼び出す。

## 4. コンポーネント間の連携シナリオ

- シナリオ1: ダーツを1本投げ、結果を記録する
    1. [UIプロセス] ユーザーがダーツボードUIをタッチする。タッチされたセグメント情報（例: T20）を取得する。
    1. [UIプロセス -> Coreプロセス (IPC)] 取得したセグメント情報と、現在のゲームID、プレイヤーIDなどを引数として、IPC経由でrecord_throw関数を呼び出す。
    1. [Coreプロセス]
        - record_throw関数が実行される。
        - カメラを制御し、ローカルPCの指定パスに姿勢動画とボード動画を保存する。
        - ゲーム種別（01 or Cricket）に応じてスコアやマーク数を計算する。
        - 計算結果を埋め込みデータベースに書き込む。
        - 更新されたゲーム全体の最新状態をオブジェクトとして構築する。
        - (RPC通信) 自身が持つRPCサーバー機能を介して、接続している全ての閲覧用ブラウザに対し、notifyGameStateUpdateプロシージャで最新のゲーム状態をブロードキャストする。
    1. [Coreプロセス -> UIプロセス (IPC)]
        - record_throw関数の戻り値として、更新後のゲーム状態をUIプロセスに返す。
    1. [UIプロセス] 戻り値を受け取り、画面上のスコア表示などを更新する。
- シナリオ2: 他PCのブラウザでリアルタイム観戦する
    1. [閲覧用ブラウザ] ユーザーが、クライアントPCのローカルIPアドレスを指定したURL（例: http://192.168.1.10:8080）にアクセスする。
    1. [閲覧用ブラウザ -> Coreプロセス (RPC)] ページが読み込まれると、ブラウザはクライアントPCのCoreプロセスが公開しているRPCエンドポイントに接続を試みる。
    1. [Coreプロセス] 新しい閲覧クライアントからの接続を確立し、通知リストに追加する。
    1. (シナリオ1のNo.3でRPC通知が発生)
    1. [Coreプロセス -> 閲覧用ブラウザ (RPC)] Coreプロセスは、通知リストにいる全てのクライアント（このブラウザを含む）に、game_state_updateイベントと最新のゲーム状態データを送信する。
    1. [閲覧用ブラウザ]
        - game_state_updateイベントを受け取る。
        - 受け取ったデータに基づき、Reactで画面のスコア表示などを動的に書き換える。
